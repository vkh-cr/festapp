CREATE OR REPLACE FUNCTION public.update_activities(
    p_occasion_id BIGINT,
    p_activities_data JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    activity_json RECORD;
    assignment_json_record RECORD;
    v_activity_id UUID;
    place_id_val BIGINT;
    event_id_val BIGINT;
    user_uuid UUID;
    assignment_id_uuid UUID;
    is_user_on_occasion BOOLEAN;

    db_activity_ids UUID[];
    incoming_activity_ids UUID[] := ARRAY[]::UUID[];
    activity_id_to_check UUID;

    incoming_assignment_ids_for_activity UUID[];
    db_assignment_id_to_check UUID;
BEGIN
    -- Authorization check
    IF (SELECT get_is_editor_on_occasion(p_occasion_id)) <> TRUE THEN
        RETURN jsonb_build_object('code', 403, 'message', 'User is not authorized to edit this occasion');
    END IF;

    -- 1. Determine activities to delete
    SELECT array_agg(id) INTO db_activity_ids FROM public.activities WHERE occasion = p_occasion_id;
    FOR activity_json IN SELECT * FROM jsonb_array_elements(p_activities_data) LOOP
        -- The ID is now always present, generated by the client
        incoming_activity_ids := array_append(incoming_activity_ids, (activity_json.value->>'id')::UUID);
    END LOOP;

    IF array_length(db_activity_ids, 1) > 0 THEN
        FOREACH activity_id_to_check IN ARRAY db_activity_ids LOOP
            IF NOT (activity_id_to_check = ANY(incoming_activity_ids)) THEN
                DELETE FROM public.activities WHERE id = activity_id_to_check;
            END IF;
        END LOOP;
    END IF;

    -- 2. Loop through each activity in the input JSON array to upsert
    FOR activity_json IN SELECT * FROM jsonb_to_recordset(p_activities_data) AS act(
        id UUID, -- All incoming activities now have a client-generated UUID
        title TEXT,
        description TEXT,
        type TEXT,
        is_hidden BOOLEAN,
        "order" INT,
        data JSONB,
        unit BIGINT,
        assignments JSONB
    )
    LOOP
        -- MODIFIED: Replaced separate INSERT and UPDATE with a single UPSERT statement.
        -- This is more efficient and handles both cases cleanly.
        INSERT INTO public.activities (id, title, description, type, occasion, unit, is_hidden, "order", data, created_at, updated_at)
        VALUES (
            activity_json.id, activity_json.title, activity_json.description, activity_json.type, p_occasion_id,
            activity_json.unit, activity_json.is_hidden, activity_json."order", activity_json.data, now(), now()
        )
        ON CONFLICT (id) DO UPDATE SET
            title = EXCLUDED.title,
            description = EXCLUDED.description,
            type = EXCLUDED.type,
            occasion = EXCLUDED.occasion,
            unit = EXCLUDED.unit,
            is_hidden = EXCLUDED.is_hidden,
            "order" = EXCLUDED."order",
            data = EXCLUDED.data,
            updated_at = now();

        -- Set v_activity_id for use in assignment logic below.
        v_activity_id := activity_json.id;

        -- Manage activity_assignments for the current activity
        incoming_assignment_ids_for_activity := ARRAY[]::UUID[];
        IF jsonb_typeof(activity_json.assignments) = 'array' THEN
            FOR assignment_json_record IN SELECT * FROM jsonb_array_elements(activity_json.assignments) LOOP
                 IF assignment_json_record.value->>'id' IS NOT NULL THEN
                    incoming_assignment_ids_for_activity := array_append(incoming_assignment_ids_for_activity, (assignment_json_record.value->>'id')::UUID);
                 END IF;
            END LOOP;
        END IF;

        FOR db_assignment_id_to_check IN SELECT id FROM public.activity_assignments WHERE activity_id = v_activity_id LOOP
            IF NOT (db_assignment_id_to_check = ANY(incoming_assignment_ids_for_activity)) THEN
                DELETE FROM public.activity_assignments WHERE id = db_assignment_id_to_check;
            END IF;
        END LOOP;

        -- Upsert assignments and their related places/events (This logic remains the same)
        IF jsonb_typeof(activity_json.assignments) = 'array' AND jsonb_array_length(activity_json.assignments) > 0 THEN
            FOR assignment_json_record IN SELECT * FROM jsonb_to_recordset(activity_json.assignments) AS ass(
                id TEXT,
                "user" TEXT,
                start_time TIMESTAMPTZ,
                end_time TIMESTAMPTZ,
                title TEXT,
                description TEXT,
                data JSONB,
                linked_place_ids JSONB,
                linked_event_ids JSONB
            )
            LOOP
                BEGIN
                    assignment_id_uuid := assignment_json_record.id::UUID;
                    IF assignment_json_record."user" IS NOT NULL THEN
                        user_uuid := assignment_json_record."user"::UUID;
                    ELSE
                        user_uuid := NULL;
                    END IF;
                EXCEPTION
                    WHEN invalid_text_representation THEN
                        RAISE WARNING 'Invalid UUID format for assignment ID: % or user: % for activity_id: %. Skipping assignment.', assignment_json_record.id, assignment_json_record."user", v_activity_id;
                        CONTINUE;
                    WHEN others THEN
                         RAISE WARNING 'Error parsing UUIDs for assignment ID: % or user: % for activity_id: %. Error: %. Skipping assignment.', assignment_json_record.id, assignment_json_record."user", v_activity_id, SQLERRM;
                        CONTINUE;
                END;

                IF user_uuid IS NOT NULL THEN
                    SELECT EXISTS (
                        SELECT 1 FROM public.occasion_users ou
                        WHERE ou.occasion = p_occasion_id AND ou."user" = user_uuid
                    ) INTO is_user_on_occasion;

                    IF NOT is_user_on_occasion THEN
                        RAISE WARNING 'User with UUID % is not associated with occasion_id %. Skipping assignment % for activity_id %.', user_uuid, p_occasion_id, assignment_id_uuid, v_activity_id;
                        CONTINUE;
                    END IF;
                END IF;

                INSERT INTO public.activity_assignments (
                    id, activity_id, "user", start_time, end_time, title, description, data
                ) VALUES (
                    assignment_id_uuid, v_activity_id, user_uuid, assignment_json_record.start_time,
                    assignment_json_record.end_time, assignment_json_record.title,
                    assignment_json_record.description, assignment_json_record.data
                )
                ON CONFLICT (id) DO UPDATE SET
                    activity_id = EXCLUDED.activity_id, "user" = EXCLUDED."user",
                    start_time = EXCLUDED.start_time, end_time = EXCLUDED.end_time,
                    title = EXCLUDED.title, description = EXCLUDED.description, data = EXCLUDED.data;

                DELETE FROM public.activity_assignment_places WHERE assignment_id = assignment_id_uuid;
                IF jsonb_typeof(assignment_json_record.linked_place_ids) = 'array' AND jsonb_array_length(assignment_json_record.linked_place_ids) > 0 THEN
                    FOR place_id_val IN SELECT jsonb_array_elements_text(assignment_json_record.linked_place_ids)::BIGINT LOOP
                        INSERT INTO public.activity_assignment_places (assignment_id, place_id)
                        VALUES (assignment_id_uuid, place_id_val)
                        ON CONFLICT (assignment_id, place_id) DO NOTHING;
                    END LOOP;
                END IF;

                DELETE FROM public.activity_assignment_events WHERE assignment_id = assignment_id_uuid;
                IF jsonb_typeof(assignment_json_record.linked_event_ids) = 'array' AND jsonb_array_length(assignment_json_record.linked_event_ids) > 0 THEN
                    FOR event_id_val IN SELECT jsonb_array_elements_text(assignment_json_record.linked_event_ids)::BIGINT LOOP
                        INSERT INTO public.activity_assignment_events (assignment_id, event_id)
                        VALUES (assignment_id_uuid, event_id_val)
                        ON CONFLICT (assignment_id, event_id) DO NOTHING;
                    END LOOP;
                END IF;

            END LOOP;
        END IF;
    END LOOP;

    RETURN jsonb_build_object('code', 200, 'message', 'Activities saved successfully.');

EXCEPTION
    WHEN others THEN
        RETURN jsonb_build_object('code', 500, 'message', 'Error saving activities: ' || SQLERRM || '. Details: ' || SQLSTATE);
END;
$$;