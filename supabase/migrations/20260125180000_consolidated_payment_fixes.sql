-- Consolidated Bank Import Migration (Schema, Logs, RPCs)
BEGIN;

---------------------------------------------------------------------------
-- 1. Table: eshop.bank_accounts
---------------------------------------------------------------------------
-- Add import_token as TEXT (allowing short tokens)
-- REMOVED per user request
DO $$
BEGIN
    -- Removed import_token addition
END $$;

-- Ensure uniqueness
-- Ensure uniqueness
ALTER TABLE eshop.bank_accounts DROP CONSTRAINT IF EXISTS bank_accounts_import_token_key;
DROP INDEX IF EXISTS idx_bank_accounts_import_token;

---------------------------------------------------------------------------
-- 2. Table: eshop.transactions
---------------------------------------------------------------------------
DO $$
BEGIN
    -- External ID (MessageID)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='external_id') THEN
        ALTER TABLE eshop.transactions ADD COLUMN external_id text;
    END IF;
     -- Sender Name -> using counter_account_name which exists
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='sender_name') THEN
       ALTER TABLE eshop.transactions DROP COLUMN sender_name;
    END IF;
     -- Bank Code (needed for pairing/parsing)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='bank_code') THEN
        ALTER TABLE eshop.transactions ADD COLUMN bank_code text;
    END IF;
    -- Counter Account (needed for pairing/parsing)
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='counter_account') THEN
        ALTER TABLE eshop.transactions ADD COLUMN counter_account text;
    END IF;

    -- Transaction ID should be nullable for manual/email imports
    ALTER TABLE eshop.transactions ALTER COLUMN transaction_id DROP NOT NULL;
END $$;

CREATE INDEX IF NOT EXISTS idx_transactions_external_id ON eshop.transactions(external_id);

---------------------------------------------------------------------------
-- 3. Table: eshop.transactions_log
---------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS eshop.transactions_log (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz DEFAULT now(),
    bank_account_id bigint REFERENCES eshop.bank_accounts(id), -- Nullable for generic errors
    external_id text,
    raw_email text,
    error_message text
);

GRANT ALL ON eshop.transactions_log TO service_role;

-- RLS
ALTER TABLE eshop.transactions_log ENABLE ROW LEVEL SECURITY;
-- Default DENY for everyone (only service_role via RPC can write/read)

---------------------------------------------------------------------------
-- 4. Constraint: Tickets State
---------------------------------------------------------------------------
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.table_constraints 
        WHERE constraint_schema = 'eshop' 
        AND table_name = 'tickets' 
        AND constraint_name = 'tickets_state_check'
    ) THEN
        ALTER TABLE eshop.tickets
        ADD CONSTRAINT tickets_state_check
        CHECK (state IN ('ordered', 'paid', 'sent', 'used', 'storno'));
    END IF;
END $$;

---------------------------------------------------------------------------
-- 5. Functions: Token Management
---------------------------------------------------------------------------

-- REMOVED import_token functions per user request

---------------------------------------------------------------------------
-- 6. Functions: Permissions (Link Bank Account)
---------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.link_bank_account_to_unit(
    p_bank_account_id bigint,
    p_unit_id bigint,
    p_priority int,
    p_hard boolean DEFAULT false
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
DECLARE
    v_conflict_data jsonb;
    v_is_reordering boolean;
BEGIN
    PERFORM check_is_manager_on_unit(p_unit_id);

    IF p_priority IS NULL THEN
        IF NOT p_hard THEN
            WITH TargetAcc AS (
                SELECT unnest(supported_currencies) as curr FROM eshop.bank_accounts WHERE id = p_bank_account_id
            ),
            OtherAccs AS (
                SELECT unnest(ba.supported_currencies) as curr
                FROM eshop.unit_bank_accounts uba
                JOIN eshop.bank_accounts ba ON uba.bank_account = ba.id
                WHERE uba.unit = p_unit_id AND uba.bank_account != p_bank_account_id
            ),
            LostCurrencies AS (
                SELECT curr FROM TargetAcc
                EXCEPT
                SELECT curr FROM OtherAccs
            ),
            ConflictingForms AS (
                SELECT DISTINCT f.title as form_title, f.link as form_link, p.currency_code, o.title as occasion_title
                FROM public.forms f
                JOIN public.occasions o ON f.occasion = o.id
                JOIN public.form_fields ff ON ff.form = f.id
                JOIN eshop.product_types pt ON ff.product_type = pt.id
                JOIN eshop.products p ON p.product_type = pt.id
                JOIN eshop.products p2 ON ff.product_type = p2.product_type -- Check if any products use currency?? Wait, the query is correct.
                WHERE o.unit = p_unit_id
                  AND f.is_open = true
                  -- AND p.is_hidden = false -- Removed is_hidden check? Original SQL had it. Let's keep it tight.
                  AND p.currency_code IN (SELECT curr FROM LostCurrencies)
            )
            SELECT jsonb_agg(jsonb_build_object('form', form_title, 'link', form_link, 'currency', currency_code, 'occasion', occasion_title))
            INTO v_conflict_data
            FROM ConflictingForms;

            IF v_conflict_data IS NOT NULL THEN
                 RAISE EXCEPTION '%', jsonb_build_object(
                    'code', 'LINK_DEPENDENCY_ERROR',
                    'message', 'Cannot unlink bank account because some active forms depend on its currency support.',
                    'conflicts', v_conflict_data
                 )::text;
            END IF;
        END IF;

        DELETE FROM eshop.unit_bank_accounts
        WHERE unit = p_unit_id AND bank_account = p_bank_account_id;
    ELSE
        v_is_reordering := EXISTS (
            SELECT 1 FROM eshop.unit_bank_accounts 
            WHERE unit = p_unit_id AND bank_account = p_bank_account_id
        );

        IF NOT v_is_reordering THEN
            IF NOT EXISTS (
                SELECT 1 FROM eshop.bank_account_users 
                WHERE bank_account = p_bank_account_id AND "user" = auth.uid() AND is_admin = true
            ) THEN
                RAISE EXCEPTION 'User is not an admin of this bank account.';
            END IF;
        END IF;

        IF v_is_reordering THEN
            UPDATE eshop.unit_bank_accounts
            SET priority = p_priority
            WHERE unit = p_unit_id AND bank_account = p_bank_account_id;
        ELSE
            INSERT INTO eshop.unit_bank_accounts (unit, bank_account, priority)
            VALUES (p_unit_id, p_bank_account_id, p_priority);
            
            IF NOT EXISTS (SELECT 1 FROM eshop.bank_account_users WHERE bank_account = p_bank_account_id AND "user" = auth.uid()) THEN
                 INSERT INTO eshop.bank_account_users (bank_account, "user", is_admin, is_support)
                 VALUES (p_bank_account_id, auth.uid(), true, true);
            END IF;
        END IF;
    END IF;
END;
$$;

---------------------------------------------------------------------------
-- 7. Functions: Logging
---------------------------------------------------------------------------
-- Ensure old function is dropped
DROP FUNCTION IF EXISTS public.log_transaction_log(bigint, text, text, text);
DROP FUNCTION IF EXISTS public.log_bank_import_error(bigint, text, text, text);

CREATE OR REPLACE FUNCTION public.log_transactions_log(
    p_bank_account_id bigint,
    p_external_id text,
    p_raw_data text,
    p_message text
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
BEGIN
    INSERT INTO eshop.transactions_log (bank_account_id, external_id, raw_email, error_message, created_at)
    VALUES (p_bank_account_id, p_external_id, p_raw_data, p_message, now());
END;
$$;

---------------------------------------------------------------------------
-- 8. Functions: Process Email Transaction (with JSONB & Pairing)
---------------------------------------------------------------------------
-- Drop old scalar signatures
DROP FUNCTION IF EXISTS public.process_email_transaction(bigint, text, numeric, text, text, text, text, text, text, timestamptz, text, bigint, text);
DROP FUNCTION IF EXISTS public.process_email_transaction(bigint, text, numeric, text, text, text, text, text, text, text, timestamptz, text, bigint, text);

CREATE OR REPLACE FUNCTION public.process_email_transaction(
    p_data jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
DECLARE
    v_bank_account_id bigint;
    v_external_id text;
    v_transaction_id bigint;
    v_variable_symbol text;
    
    v_existing_id bigint;
    v_new_id int;
    v_payment_info_id bigint;
BEGIN
    v_bank_account_id := (p_data->>'bank_account_id')::bigint;
    v_external_id := p_data->>'external_id';
    v_transaction_id := (p_data->>'transaction_id')::bigint;
    v_variable_symbol := p_data->>'vs';

    IF v_bank_account_id IS NOT NULL THEN
        UPDATE eshop.bank_accounts 
        SET last_fetch_time = now(), 
            updated_at = now() 
        WHERE id = v_bank_account_id;
    END IF;

    IF v_transaction_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE bank_account_id = v_bank_account_id AND transaction_id = v_transaction_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_transaction_id', 'id', v_existing_id);
        END IF;
    END IF;

    IF v_external_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE external_id = v_external_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_external_id', 'id', v_existing_id);
        END IF;
    END IF;

    -- 3. Fuzzy Deduplication (VS + Amount + Currency + Date)
    IF v_variable_symbol IS NOT NULL AND v_variable_symbol != '' THEN
        SELECT id INTO v_existing_id
        FROM eshop.transactions
        WHERE bank_account_id = v_bank_account_id
          AND vs = v_variable_symbol
          AND amount = (p_data->>'amount')::numeric
          AND currency = p_data->>'currency'
          AND date::date = (p_data->>'date')::timestamptz::date
        LIMIT 1;

        IF v_existing_id IS NOT NULL THEN
             RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_fuzzy', 'id', v_existing_id);
        END IF;
    END IF;

    INSERT INTO eshop.transactions (
        bank_account_id,
        amount,
        currency,
        counter_account,
        bank_code,
        vs,
        ks,
        ss,
        message_for_recipient,
        date,
        created_at,
        external_id,
        transaction_id,
        counter_account_name,
        bank_name
    ) VALUES (
        v_bank_account_id,
        (p_data->>'amount')::numeric,
        p_data->>'currency',
        p_data->>'counter_account',
        p_data->>'bank_code',
        v_variable_symbol,
        p_data->>'ks',
        p_data->>'ss',
        p_data->>'message',
        (p_data->>'date')::timestamptz,
        now(),
        v_external_id,
        v_transaction_id,
        p_data->>'sender_name',
        p_data->>'bank_name'
    )
    RETURNING id INTO v_new_id;

    IF v_variable_symbol IS NOT NULL AND v_variable_symbol != '' THEN
        BEGIN
            SELECT id INTO v_payment_info_id
            FROM eshop.payment_info
            WHERE variable_symbol = v_variable_symbol::bigint
              AND bank_account = v_bank_account_id
            LIMIT 1;
        EXCEPTION WHEN OTHERS THEN
             v_payment_info_id := NULL;
        END;

        IF v_payment_info_id IS NOT NULL THEN
             PERFORM public.add_transaction_to_payment_info(v_new_id::bigint, v_payment_info_id);
        END IF;
    END IF;

    RETURN jsonb_build_object('status', 'inserted', 'id', v_new_id, 'paired', v_payment_info_id IS NOT NULL);
END;
$$;

---------------------------------------------------------------------------
-- 9. Functions: Manual Transaction (Updated Logic)
---------------------------------------------------------------------------
-- RLS Policy: Managers
DROP POLICY IF EXISTS "Managers can view transactions for their units" ON eshop.transactions;

CREATE POLICY "Managers can view transactions for their units"
ON eshop.transactions
FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 
        FROM eshop.unit_bank_accounts uba
        JOIN public.unit_users uu ON uba.unit = uu.unit
        WHERE uba.bank_account = eshop.transactions.bank_account_id
          AND uu."user" = auth.uid()
          AND uu.is_manager = true
    )
);

DROP FUNCTION IF EXISTS public.insert_manual_transaction(numeric, text, int, text, timestamp with time zone, text);
DROP FUNCTION IF EXISTS public.insert_manual_transaction(double precision, text, int, text, text, text);
DROP FUNCTION IF EXISTS public.insert_manual_transaction(double precision, text, int, text, text, text, int);
DROP FUNCTION IF EXISTS public.insert_manual_transaction(double precision, text, int, text, text, text, bigint);

CREATE OR REPLACE FUNCTION public.insert_manual_transaction(
    p_amount double precision,
    p_currency text,
    p_unit_id int,
    p_variable_symbol text,
    p_date text,
    p_note text DEFAULT NULL,
    p_payment_info_id int DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
DECLARE
    v_account_id int;
    v_date timestamp with time zone;
    v_new_transaction_id bigint;
    v_payment_info_id bigint;
BEGIN
    PERFORM public.check_is_manager_on_unit(p_unit_id);
    v_date := p_date::timestamp with time zone;

    SELECT ba.id INTO v_account_id
    FROM eshop.bank_accounts ba
    JOIN eshop.unit_bank_accounts uba ON ba.id = uba.bank_account
    WHERE uba.unit = p_unit_id 
      AND ba.type = 'CASH'
      AND p_currency = ANY(ba.supported_currencies);

    IF v_account_id IS NULL THEN
        INSERT INTO eshop.bank_accounts (
            title, type, supported_currencies, account_number, account_number_human_readable
        ) VALUES (
            'Cash Account (' || p_currency || ')', 'CASH', ARRAY[p_currency], '', ''
        )
        RETURNING id INTO v_account_id;

        INSERT INTO eshop.unit_bank_accounts (unit, bank_account, priority)
        VALUES (p_unit_id, v_account_id, 0);
    END IF;

    INSERT INTO eshop.transactions (
        bank_account_id,
        transaction_id,
        amount,
        currency,
        date,
        vs,
        message_for_recipient,
        transaction_type,
        created_by
    ) VALUES (
        v_account_id,
        ('-1' || (extract(epoch from now()) * 1000)::bigint::text)::bigint, 
        p_amount,
        p_currency,
        v_date,
        p_variable_symbol,
        p_note,
        'manual',
        auth.uid()
    )
    RETURNING id INTO v_new_transaction_id;

    IF p_payment_info_id IS NOT NULL THEN
         v_payment_info_id := p_payment_info_id;
    ELSIF p_variable_symbol IS NOT NULL AND p_variable_symbol != '' THEN
        BEGIN
            SELECT id INTO v_payment_info_id
            FROM eshop.payment_info
            WHERE variable_symbol = p_variable_symbol::bigint
            LIMIT 1;
        EXCEPTION WHEN OTHERS THEN
             v_payment_info_id := NULL;
        END;
    END IF;

    IF v_payment_info_id IS NOT NULL THEN
            PERFORM public.add_transaction_to_payment_info(v_new_transaction_id, v_payment_info_id);
    END IF;
END;
$$;

GRANT EXECUTE ON FUNCTION public.insert_manual_transaction(double precision, text, int, text, text, text, int) TO authenticated;

-- Internal Functions: Revoke Public, Grant Service Role Only
REVOKE ALL ON FUNCTION public.process_email_transaction(jsonb) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.process_email_transaction(jsonb) TO service_role;

REVOKE ALL ON FUNCTION public.log_transactions_log(bigint, text, text, text) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.log_transactions_log(bigint, text, text, text) TO service_role;

---------------------------------------------------------------------------
-- 10. Fixes: Order Payment Reversion Logic
---------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.recalculate_order_payment_status(p_order_id bigint)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    v_payment_info_id bigint;
    v_paid numeric;
    v_price numeric;
    v_state text;
BEGIN
    -- Get Order Details
    SELECT payment_info, price, state INTO v_payment_info_id, v_price, v_state
    FROM eshop.orders
    WHERE id = p_order_id;

    IF v_payment_info_id IS NULL THEN
        RETURN;
    END IF;

    -- Get Paid Amount from Payment Info
    SELECT paid INTO v_paid
    FROM eshop.payment_info
    WHERE id = v_payment_info_id;

    -- Update Logic
    IF COALESCE(v_paid, 0) >= v_price THEN
        -- Fully Paid -> Move to Paid
        IF v_state != 'paid' AND (v_state = 'ordered' OR v_state = 'created' OR v_state = 'expired') THEN
             PERFORM public.update_order_and_tickets_to_paid(p_order_id);
        END IF;
    ELSE
        -- Underpaid -> Revert to Ordered (if currently Paid)
        IF v_state = 'paid' THEN
            -- Revert Order
            UPDATE eshop.orders
            SET state = 'ordered', updated_at = now()
            WHERE id = p_order_id;
            
            -- Revert Tickets (only those that are 'paid')
            UPDATE eshop.tickets
            SET state = 'ordered', updated_at = now() -- Reverted to 'ordered' as 'valid' is not a supported state

            FROM eshop.order_product_ticket
            WHERE eshop.order_product_ticket.ticket = eshop.tickets.id
            AND eshop.order_product_ticket."order" = p_order_id
            AND eshop.tickets.state = 'paid';
        END IF;
    END IF;
END;
$$;

COMMIT;
-- Fix Cash Account Priority bug
-- Exclude 'CASH' accounts from:
-- 1. Automatic selection in create_ticket_order
-- 2. Validation in create_ticket_order
-- 3. Form Editor available accounts list
-- 4. Unit Admin Management list

BEGIN;

---------------------------------------------------------------------------
-- 1. Update create_ticket_order
---------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION create_ticket_order(input_data JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    result JSONB;
    order_id BIGINT;
    ticket_data JSONB;
    spot_data RECORD;
    spot_id BIGINT;
    spot_product RECORD;
    now TIMESTAMPTZ := NOW();
    calculated_price NUMERIC(10,2) := 0;
    spot_secret UUID;
    product_id BIGINT;
    ordered_count BIGINT;
    used_spots JSONB := '[]'::JSONB;
    occasion_id BIGINT;
    organization_id BIGINT;
    unit_id BIGINT;
    occasion_title TEXT;
    occasion_features JSONB;
    account_number TEXT;
    account_number_human_readable TEXT;
    ticket_details JSONB := '[]'::JSONB;
    product_data RECORD;
    ticket_id BIGINT;
    order_product_ticket_id BIGINT;
    ticket_symbol TEXT;
    ticket_products JSONB := '[]'::JSONB;
    payment_info_id BIGINT;
    generated_variable_symbol BIGINT;
    bank_account_id BIGINT;
    form_key UUID;
    deadline TIMESTAMPTZ;
    form_deadline_duration BIGINT;
    form_data JSONB;
    currency_code TEXT;
    first_currency_code TEXT := NULL;
    field_item JSONB;
    products_array BIGINT[] := '{}';
    form_id BIGINT;
    field_type TEXT;
    key_val RECORD;
    order_data JSONB;
    order_note TEXT;
    ticket_note TEXT;
    reply_to TEXT;
    is_open_val BOOLEAN;
    is_editor BOOLEAN;
BEGIN
    -- Wrap the entirelogic in a subtransaction block
    BEGIN
        -- Validate input_data and extract form key and email
        IF input_data IS NULL OR input_data->'form' IS NULL THEN
            RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1001, 'message', 'Missing form key in input data')::TEXT;
        END IF;

        form_key := (input_data->>'form')::UUID;
        SELECT id, occasion, bank_account, deadline_duration_seconds, data, is_open
        INTO form_id, occasion_id, bank_account_id, form_deadline_duration, form_data, is_open_val
        FROM public.forms
        WHERE key = form_key;

        IF occasion_id IS NULL THEN
            RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1003, 'message', 'Form is not linked to any occasion')::TEXT;
        END IF;

        is_editor := public.get_is_editor_order_on_occasion(occasion_id);

        IF NOT is_editor THEN
            IF is_open_val IS FALSE THEN
                 RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1021, 'message', 'Form is closed')::TEXT;
            END IF;

            -- Check for start_time and end_time constraints only if not editor
            IF COALESCE(form_data->'schedule'->>'start_time', form_data->>'start_time') IS NOT NULL THEN
                IF now < (COALESCE(form_data->'schedule'->>'start_time', form_data->>'start_time'))::TIMESTAMPTZ THEN
                    RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1019, 'message', 'Form is not yet open')::TEXT;
                END IF;
            END IF;

            IF COALESCE(form_data->'schedule'->>'end_time', form_data->>'end_time') IS NOT NULL THEN
                IF now > (COALESCE(form_data->'schedule'->>'end_time', form_data->>'end_time'))::TIMESTAMPTZ THEN
                    RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1020, 'message', 'Form is closed')::TEXT;
                END IF;
            END IF;
        END IF;

        -- Fetch organization, unit, and occasion title from the occasion
        SELECT organization, unit, title, features
        INTO organization_id, unit_id, occasion_title, occasion_features
        FROM public.occasions
        WHERE id = occasion_id;

        IF organization_id IS NULL THEN
            RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1005, 'message', 'No organization found for the occasion')::TEXT;
        END IF;

        IF input_data ? 'fields' THEN
            DECLARE
                valid_fields JSONB := '[]'::JSONB;
                elem JSONB;
                field_key TEXT;
            BEGIN
                FOR elem IN SELECT * FROM jsonb_array_elements(input_data->'fields')
                LOOP
                    field_key := (SELECT key FROM jsonb_object_keys(elem) AS key);

                    IF field_key IS NULL THEN
                        CONTINUE;
                    END IF;

                    -- Validate the field against the form_fields table
                    SELECT ff.type INTO field_type
                    FROM public.form_fields ff
                    WHERE ff.id = field_key::BIGINT AND ff.form = form_id AND ff.is_hidden = false;

                    IF FOUND THEN
                        valid_fields := valid_fields || elem;

                        IF field_type IN ('email', 'name', 'surname', 'phone', 'note') THEN
                            input_data := jsonb_set(input_data, ARRAY[field_type], elem->field_key, true);
                        END IF;
                    END IF;
                END LOOP;

                input_data := jsonb_set(input_data, '{fields}', valid_fields);
            END;
        END IF;

        IF input_data->>'email' IS NULL THEN
            RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1002, 'message', 'Missing email in input data')::TEXT;
        END IF;

        INSERT INTO eshop.orders (created_at, updated_at, occasion, form)
        VALUES (now, now, occasion_id, form_id)
        RETURNING id INTO order_id;

        -- Process each ticket
        FOR ticket_data IN SELECT * FROM JSONB_ARRAY_ELEMENTS(input_data->'ticket') LOOP

            spot_data := NULL;
            spot_product := NULL;
            spot_id := NULL;
            ticket_note := NULL;

            IF ticket_data->>'spot' IS NOT NULL THEN
                SELECT * INTO spot_data
                FROM eshop.spots
                WHERE id = (ticket_data->>'spot')::BIGINT
                  AND occasion = occasion_id;

                IF spot_data IS NULL THEN
                    RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1007, 'message', 'Invalid or unrelated spot')::TEXT;
                END IF;

                IF spot_data.order_product_ticket IS NOT NULL THEN
                    RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1008, 'message', 'Spot is already reserved or in use')::TEXT;
                END IF;

                spot_secret := (input_data->>'secret')::UUID;
                IF spot_data.secret IS DISTINCT FROM spot_secret THEN
                    RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1009, 'message', 'Invalid secret for spot')::TEXT;
                END IF;

                spot_id := spot_data.id;
                used_spots := used_spots || JSONB_BUILD_ARRAY(spot_id);

                SELECT i.*, it.type, it.title as type_title, spot_data.title as spot_title
                INTO spot_product
                FROM eshop.products i
                LEFT JOIN eshop.product_types it ON i.product_type = it.id
                WHERE i.id = spot_data.product;
            END IF;

            products_array := '{}';
            IF ticket_data ? 'fields' THEN
                FOR field_item IN SELECT * FROM JSONB_ARRAY_ELEMENTS(ticket_data->'fields')
                LOOP
                    IF field_item ? 'note' THEN
                        ticket_note := field_item->>'note';
                    END IF;
                    IF field_item ? 'product_type' THEN
                        products_array := products_array || ((field_item->>'product_type')::BIGINT);
                    END IF;
                END LOOP;
            END IF;

            ticket_symbol := generate_ticket_symbol(organization_id, occasion_id);
            INSERT INTO eshop.tickets (state, occasion, ticket_symbol, note, created_at, updated_at)
            VALUES ('ordered', occasion_id, ticket_symbol, ticket_note, now, now)
            RETURNING id INTO ticket_id;

            ticket_products := '[]'::JSONB;

            IF spot_id IS NOT NULL THEN
                products_array := products_array || spot_product.id;
            END IF;

            FOREACH product_id IN ARRAY products_array LOOP

                IF product_id IS NULL THEN
                    CONTINUE;
                END IF;

                SELECT i.*, it.type, it.title AS type_title, '' AS spot_title
                INTO product_data
                FROM eshop.products i
                LEFT JOIN eshop.product_types it ON i.product_type = it.id
                WHERE i.id = product_id
                  AND it.occasion = occasion_id;

                IF product_data IS NULL THEN
                    RAISE EXCEPTION '%',
                        jsonb_build_object(
                            'code', 1011,
                            'message', 'Product not found or not part of occasion',
                            'details', product_id
                        )::text;
                END IF;

                IF COALESCE(product_data.maximum, 0) > 0 THEN
                    SELECT COUNT(*) INTO ordered_count
                    FROM eshop.order_product_ticket
                    WHERE product = product_id;
                    IF ordered_count + 1 > product_data.maximum THEN
                        RAISE EXCEPTION '%', JSONB_BUILD_OBJECT(
                            'code', 1017,
                            'message', 'Product is overbooked',
                            'product', jsonb_strip_nulls(JSONB_BUILD_OBJECT(
                                'id', product_data.id,
                                'title', product_data.title,
                                'price', product_data.price,
                                'type', product_data.type,
                                'currency_code', product_data.currency_code
                            ))
                        )::TEXT;
                    END IF;
                END IF;

                IF product_data.type = 'spot' AND spot_product IS NULL THEN
                    spot_product := product_data;
                END IF;

                IF product_data.is_hidden THEN
                    RAISE EXCEPTION '%', JSONB_BUILD_OBJECT(
                        'code', 1012,
                        'message', 'Selected product is hidden and cannot be ordered',
                        'id', product_id
                    )::TEXT;
                END IF;

                IF first_currency_code IS NULL THEN
                    first_currency_code := product_data.currency_code;
                ELSE
                    IF product_data.currency_code IS DISTINCT FROM first_currency_code THEN
                        RAISE EXCEPTION '%', JSONB_BUILD_OBJECT(
                            'code', 1014,
                            'message', 'Products in the order must have the same currency',
                            'expected_currency', first_currency_code,
                            'actual_currency', product_data.currency_code
                        )::TEXT;
                    END IF;
                END IF;

                -- Build the product details for the ticket
                DECLARE
                    v_spot_title TEXT := NULL;
                    v_spot_description TEXT := NULL;
                BEGIN
                    -- Safe extraction of spot details
                    IF spot_id IS NOT NULL AND spot_product IS NOT NULL THEN
                         -- Only access fields if we have a spot_id (implies spot_product is fully set from spot lookup)
                         -- AND product_id matches.
                         IF product_id = spot_product.id THEN
                             v_spot_title := spot_product.spot_title;
                             v_spot_description := spot_product.description;
                         END IF;
                    END IF;

                    ticket_products := ticket_products || jsonb_strip_nulls(JSONB_BUILD_OBJECT(
                        'id', product_id,
                        'title', product_data.title,
                        'type', product_data.type,
                        'type_title', product_data.type_title,
                        'price', product_data.price,
                        'currency_code', product_data.currency_code,
                        'spot_title', v_spot_title,
                        'description', v_spot_description,
                        'data', product_data.data
                    ));
                END;

                calculated_price := calculated_price + COALESCE(product_data.price, 0)::NUMERIC(10,2);

                INSERT INTO eshop.order_product_ticket ("order", product, ticket)
                VALUES (order_id, product_id, ticket_id)
                RETURNING id INTO order_product_ticket_id;

                IF spot_id IS NOT NULL THEN
                    IF product_id = spot_product.id THEN
                        UPDATE eshop.spots
                        SET order_product_ticket = order_product_ticket_id, updated_at = now
                        WHERE id = spot_id;
                    END IF;
                END IF;
            END LOOP;

            IF spot_product IS NULL THEN
                RAISE EXCEPTION '%', JSONB_BUILD_OBJECT('code', 1015, 'message', 'Spot product is missing in ticket fields')::TEXT;
            END IF;

            ticket_details := ticket_details || JSONB_BUILD_OBJECT(
                'id', ticket_id,
                'ticket_symbol', ticket_symbol,
                'note', ticket_note,
                'products', ticket_products
            );
        END LOOP;

        order_data := input_data - 'ticket' || JSONB_BUILD_OBJECT('tickets', ticket_details);

        -- Modified Bank Account Selection: Exclude CASH Accounts
        IF bank_account_id IS NULL THEN
            SELECT uba.bank_account, ba.account_number, ba.account_number_human_readable
            INTO bank_account_id, account_number, account_number_human_readable
            FROM eshop.unit_bank_accounts uba
            JOIN eshop.bank_accounts ba ON uba.bank_account = ba.id
            WHERE uba.unit = (SELECT unit FROM public.occasions WHERE id = occasion_id)
              AND ba.supported_currencies @> ARRAY[first_currency_code]
              AND (ba.type IS DISTINCT FROM 'CASH') -- EXCLUDE CASH ACCOUNTS
            ORDER BY uba.priority ASC, ba.id ASC
            LIMIT 1;
            
            IF bank_account_id IS NULL THEN
                RAISE EXCEPTION '%', JSONB_BUILD_OBJECT(
                    'code', 1018,
                    'message', 'No available bank account supports the required currency',
                    'required_currency', first_currency_code
                )::TEXT;
            END IF;
        ELSE
            -- Validate manually selected account: Exclude CASH Accounts
            PERFORM 1
            FROM eshop.unit_bank_accounts uba
            JOIN eshop.bank_accounts ba ON uba.bank_account = ba.id
            WHERE uba.unit = (SELECT unit FROM public.occasions WHERE id = occasion_id)
              AND ba.id = bank_account_id
              AND ba.supported_currencies @> ARRAY[first_currency_code]
              AND (ba.type IS DISTINCT FROM 'CASH'); -- EXCLUDE CASH ACCOUNTS

            IF NOT FOUND THEN
                RAISE EXCEPTION '%', JSONB_BUILD_OBJECT(
                    'code', 1018,
                    'message', 'The specified bank account does not support the required currency, is not linked, or is invalid (CASH type)',
                    'expected_currency', first_currency_code,
                    'provided_bank_account', bank_account_id
                )::TEXT;
            END IF;
            
            SELECT b.account_number, b.account_number_human_readable
            INTO account_number, account_number_human_readable
            FROM eshop.bank_accounts b
            WHERE b.id = bank_account_id;
        END IF;

        generated_variable_symbol := generate_payment_variable_symbol(bank_account_id, form_id);
        INSERT INTO eshop.payment_info (bank_account, variable_symbol, amount, currency_code, created_at)
        VALUES (bank_account_id, generated_variable_symbol, calculated_price, first_currency_code, now)
        RETURNING id INTO payment_info_id;

        UPDATE eshop.orders
        SET
          price         = calculated_price,
          currency_code = first_currency_code,
          payment_info  = payment_info_id,
          data          = order_data,
          updated_at    = now
        WHERE id = order_id;

        PERFORM apply_allocations(order_id);

        IF calculated_price = 0 THEN
          PERFORM update_order_and_tickets_to_paid(order_id);
        ELSE
          UPDATE eshop.orders
          SET state      = 'ordered'
          WHERE id = order_id;

          IF form_deadline_duration IS NOT NULL THEN
              deadline := now + make_interval(secs => form_deadline_duration);
              PERFORM public.set_payment_deadline(payment_info_id, deadline);
          ELSE
              deadline := NULL;
          END IF;
        END IF;

        PERFORM public.recalculate_order_payment_status(order_id);

        INSERT INTO eshop.orders_history (created_at, data, "order", state, price, currency_code)
        VALUES (
            now,
            JSONB_BUILD_OBJECT('input_data', input_data, 'tickets', ticket_details),
            order_id,
            'ordered',
            calculated_price,
            first_currency_code
        );

        reply_to := get_reply_to_email_for_order(order_id);
        PERFORM public.process_occasion_auto_import(occasion_id);

        result := JSONB_BUILD_OBJECT(
            'code', 200,
            'order', JSONB_BUILD_OBJECT(
                'id', order_id,
                'data', order_data,
                'form', JSONB_BUILD_OBJECT(
                    'id', form_id,
                    'data', form_data
                ),
                'payment_info', JSONB_BUILD_OBJECT(
                    'id', payment_info_id,
                    'variable_symbol', generated_variable_symbol,
                    'amount', calculated_price,
                    'deadline', deadline,
                    'account_number', account_number,
                    'account_number_human_readable', account_number_human_readable,
                    'currency_code', first_currency_code
                ),
                'occasion', JSONB_BUILD_OBJECT(
                    'id', occasion_id,
                    'organization', organization_id,
                    'unit', unit_id,
                    'title', occasion_title,
                    'features', occasion_features
                ),
                'reply_to', reply_to
            )
        );

    EXCEPTION WHEN OTHERS THEN
        result := CASE
            WHEN left(SQLERRM, 1) = '{' THEN SQLERRM::JSONB
            ELSE JSONB_BUILD_OBJECT('code', 1013, 'message', SQLERRM)
        END;
    END;

    RETURN result;
END;
$$;

---------------------------------------------------------------------------
-- 2. Update get_form_for_edit
---------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION get_form_for_edit(form_link TEXT)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_form_id BIGINT;
    v_occasion_id BIGINT;
    v_unit_id BIGINT;
    formData JSONB;
    formFieldsData JSONB;
    productTypesData JSONB;
    productsData JSONB;
    availableBankAccountsData JSONB;
BEGIN
    SELECT
        f.id,
        f.occasion,
        o.unit
    INTO
        v_form_id,
        v_occasion_id,
        v_unit_id
    FROM public.forms f
    JOIN public.occasions o ON f.occasion = o.id
    WHERE f.link = form_link;

    IF v_form_id IS NULL THEN
        RETURN jsonb_build_object('code', 404, 'message', 'Form not found for the provided link.');
    END IF;

    PERFORM check_is_editor_order_view_via_form_link(form_link);

    SELECT jsonb_build_object(
        'id', f.id,
        'key', f.key,
        'is_open', f.is_open,
        'created_at', f.created_at,
        'data', f.data,
        'type', f.type,
        'title', f.title,
        'header', f.header,
        'header_off', f.header_off,
        'occasion', f.occasion,
        'blueprint', f.blueprint,
        'link', f.link,
        'bank_account', f.bank_account,
        'deadline_duration_seconds', f.deadline_duration_seconds
    )
    INTO formData
    FROM public.forms f
    WHERE f.id = v_form_id;

    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'id', ff.id,
            'form', ff.form,
            'title', ff.title,
            'description', ff.description,
            'data', ff.data,
            'type', ff.type,
            'is_required', ff.is_required,
            'is_hidden', ff.is_hidden,
            'is_ticket_field', ff.is_ticket_field,
            'order', ff."order",
            'product_type', ff.product_type
        ) ORDER BY COALESCE(ff."order", 0)
    ), '[]'::jsonb)
    INTO formFieldsData
    FROM public.form_fields ff
    WHERE ff.form = v_form_id;

    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'id', pt.id,
            'title', pt.title,
            'description', pt.description,
            'type', pt.type,
            'data', pt.data,
            'occasion', pt.occasion
        ) ORDER BY pt.title
    ), '[]'::jsonb)
    INTO productTypesData
    FROM eshop.product_types pt
    WHERE pt.occasion = v_occasion_id;

    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'id', p.id,
            'occasion', p.occasion,
            'title', p.title,
            'description', p.description,
            'price', p.price,
            'currency_code', p.currency_code,
            'is_hidden', p.is_hidden,
            'order', p."order",
            'product_type', p.product_type,
            'ordered_count', (
                SELECT count(*)
                FROM eshop.order_product_ticket opt
                JOIN eshop.orders o ON opt."order" = o.id
                WHERE opt.product = p.id AND o.state <> 'storno'
            ),
            'maximum', p.maximum,
            'data', p.data
        ) ORDER BY COALESCE(p."order", 0)
    ), '[]'::jsonb)
    INTO productsData
    FROM eshop.products p
    WHERE p.product_type IN (SELECT id FROM eshop.product_types WHERE occasion = v_occasion_id);

    -- FIX: Exclude CASH accounts and ensure deterministic sorting by Priority
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'id', ba.id,
            'account_number', ba.account_number,
            'account_number_human_readable', ba.account_number_human_readable,
            'title', ba.title,
            'supported_currencies', ba.supported_currencies,
            'type', ba.type -- Adding type for debugging/verification
        ) ORDER BY uba.priority ASC, ba.id ASC
    ), '[]'::jsonb)
    INTO availableBankAccountsData
    FROM eshop.unit_bank_accounts uba
    JOIN eshop.bank_accounts ba ON uba.bank_account = ba.id
    WHERE uba.unit = v_unit_id
      AND (ba.type IS DISTINCT FROM 'CASH'); -- EXCLUDE CASH ACCOUNTS

    RETURN jsonb_build_object(
        'code', 200,
        'data', jsonb_build_object(
            'form', formData,
            'form_fields', formFieldsData,
            'product_types', productTypesData,
            'products', productsData,
            'available_bank_accounts', availableBankAccountsData
        )
    );
END;
$$;

---------------------------------------------------------------------------
-- 3. Update get_bank_accounts_for_unit_management
---------------------------------------------------------------------------
DROP FUNCTION IF EXISTS public.get_bank_accounts_for_unit_management(p_unit_id bigint);

CREATE OR REPLACE FUNCTION public.get_bank_accounts_for_unit_management(p_unit_id bigint)
RETURNS TABLE (
    id bigint,
    account_number text,
    title text,
    priority int,
    type text,
    is_admin boolean,
    token_masked text,
    token_valid_until timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT
        ba.id,
        ba.account_number,
        ba.title,
        uba.priority,
        ba.type,
        EXISTS(SELECT 1 FROM eshop.bank_account_users bau WHERE bau.bank_account = ba.id AND bau."user" = auth.uid() AND bau.is_admin = true) as is_admin,
        CASE WHEN s.secret IS NULL THEN NULL
             WHEN length(s.secret) <= 4 THEN '****'
             ELSE '****' || right(s.secret, 4)
        END as token_masked,
        ba.token_valid_until
    FROM eshop.bank_accounts ba
    JOIN eshop.unit_bank_accounts uba ON ba.id = uba.bank_account
    LEFT JOIN eshop.secrets s ON ba.secret = s.id
    WHERE uba.unit = p_unit_id
      AND (ba.type IS DISTINCT FROM 'CASH') -- EXCLUDE CASH ACCOUNTS from management view
    ORDER BY uba.priority ASC, ba.id ASC;
END;
$$;

COMMIT;
NOTIFY pgrst, 'reload schema';
-- Migration: Add bank_name column and bank code mapping logic
-- Date: 2026-01-24
-- Description: Adds bank_name to transactions, creates a helper to resolve bank names from codes, backfills existing data, and updates processing logic.

BEGIN;

-- 1. Add bank_name column if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='bank_name') THEN
        ALTER TABLE eshop.transactions ADD COLUMN bank_name text;
    END IF;
END $$;

-- 2. Create helper function for Bank Code -> Bank Name
CREATE OR REPLACE FUNCTION public.get_bank_name_from_code(p_code text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
    -- Common Czech Banks
    RETURN CASE p_code
        WHEN '0100' THEN 'Komerční banka'
        WHEN '0300' THEN 'ČSOB'
        WHEN '0600' THEN 'MONETA Money Bank'
        WHEN '0800' THEN 'Česká spořitelna'
        WHEN '2010' THEN 'Fio banka'
        WHEN '2060' THEN 'Citfin'
        WHEN '2070' THEN 'Markov'
        WHEN '2200' THEN 'Peněžní dům'
        WHEN '2220' THEN 'Artemis'
        WHEN '2240' THEN 'Poštová banka'
        WHEN '2250' THEN 'Banka CREDITAS'
        WHEN '2260' THEN 'Moravský Peněžní Ústav'
        WHEN '2275' THEN 'Podnikatelská družstevní záložna'
        WHEN '2400' THEN 'The Royal Bank of Scotland'
        WHEN '2600' THEN 'Citibank'
        WHEN '2700' THEN 'UniCredit Bank'
        WHEN '3030' THEN 'Air Bank'
        WHEN '3050' THEN 'BNP Paribas'
        WHEN '3060' THEN 'PKO BP'
        WHEN '3500' THEN 'ING Bank'
        WHEN '4000' THEN 'Max banka' -- Formerly Expobank
        WHEN '4300' THEN 'Českomoravská záruční a rozvojová banka'
        WHEN '5500' THEN 'Raiffeisenbank'
        WHEN '6000' THEN 'PPF banka'
        WHEN '6210' THEN 'mBank'
        WHEN '6300' THEN 'BNP Paribas Fortis'
        WHEN '6700' THEN 'Všeobecná úverová banka'
        WHEN '7910' THEN 'Deutsche Bank'
        WHEN '7940' THEN 'Waldviertler Sparkasse Bank'
        WHEN '7950' THEN 'Raiffeisen stavební spořitelna'
        WHEN '7960' THEN 'Českomoravská stavební spořitelna'
        WHEN '7970' THEN 'Wüstenrot - stavební spořitelna'
        WHEN '7980' THEN 'Wüstenrot hypoteční banka'
        WHEN '7990' THEN 'Modrá pyramida'
        WHEN '8030' THEN 'Raiffeisenbank im Stiftland'
        WHEN '8040' THEN 'Oberbank'
        WHEN '8060' THEN 'Stavební spořitelna České spořitelny'
        WHEN '8090' THEN 'Česká exportní banka'
        WHEN '8150' THEN 'HSBC'
        WHEN '8200' THEN 'Privatbanka'
        WHEN '8220' THEN 'Payment Execution'
        WHEN '8230' THEN 'EEP'
        WHEN '8240' THEN 'Družstevní záložna Kredit'
        WHEN '8250' THEN 'Bank of China'
        WHEN '8255' THEN 'Bank of Communications'
        WHEN '8260' THEN 'Industrial and Commercial Bank of China'
        WHEN '8265' THEN 'China Construction Bank'
        ELSE NULL
    END;
END;
$$;

-- 3. Backfill bank_name for existing transactions
UPDATE eshop.transactions
SET bank_name = public.get_bank_name_from_code(bank_code)
WHERE bank_name IS NULL AND bank_code IS NOT NULL;

-- 4. Update process_email_transaction to include bank_name logic
CREATE OR REPLACE FUNCTION public.process_email_transaction(
    p_data jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
DECLARE
    v_bank_account_id bigint;
    v_external_id text;
    v_transaction_id bigint;
    v_variable_symbol text;
    v_bank_code text;
    v_bank_name text;
    
    v_existing_id bigint;
    v_new_id int;
    v_payment_info_id bigint;
BEGIN
    v_bank_account_id := (p_data->>'bank_account_id')::bigint;
    v_external_id := p_data->>'external_id';
    v_transaction_id := (p_data->>'transaction_id')::bigint;
    v_variable_symbol := p_data->>'vs';
    v_bank_code := p_data->>'bank_code';
    
    -- Derive bank_name from code if not provided in JSON
    v_bank_name := p_data->>'bank_name';
    IF v_bank_name IS NULL AND v_bank_code IS NOT NULL THEN
        v_bank_name := public.get_bank_name_from_code(v_bank_code);
    END IF;

    IF v_bank_account_id IS NOT NULL THEN
        UPDATE eshop.bank_accounts 
        SET last_fetch_time = now(), 
            updated_at = now() 
        WHERE id = v_bank_account_id;
    END IF;

    IF v_transaction_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE bank_account_id = v_bank_account_id AND transaction_id = v_transaction_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_transaction_id', 'id', v_existing_id);
        END IF;
    END IF;

    IF v_external_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE external_id = v_external_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_external_id', 'id', v_existing_id);
        END IF;
    END IF;

    INSERT INTO eshop.transactions (
        bank_account_id,
        amount,
        currency,
        counter_account,
        bank_code,
        bank_name,
        vs,
        ks,
        ss,
        message_for_recipient,
        date,
        created_at,
        external_id,
        transaction_id,
        counter_account_name
    ) VALUES (
        v_bank_account_id,
        (p_data->>'amount')::numeric,
        p_data->>'currency',
        p_data->>'counter_account',
        v_bank_code,
        v_bank_name,
        v_variable_symbol,
        p_data->>'ks',
        p_data->>'ss',
        p_data->>'message',
        (p_data->>'date')::timestamptz,
        now(),
        v_external_id,
        v_transaction_id,
        p_data->>'sender_name'
    )
    RETURNING id INTO v_new_id;

    IF v_variable_symbol IS NOT NULL AND v_variable_symbol != '' THEN
        BEGIN
            SELECT id INTO v_payment_info_id
            FROM eshop.payment_info
            WHERE variable_symbol = v_variable_symbol::bigint
            LIMIT 1;
        EXCEPTION WHEN OTHERS THEN
             v_payment_info_id := NULL;
        END;

        IF v_payment_info_id IS NOT NULL THEN
             PERFORM public.add_transaction_to_payment_info(v_new_id::bigint, v_payment_info_id);
        END IF;
    END IF;

    RETURN jsonb_build_object('status', 'inserted', 'id', v_new_id, 'paired', v_payment_info_id IS NOT NULL);
END;
$$;

COMMIT;
-- Migration: Cleanup Redundant Columns in eshop.transactions
-- Date: 2026-01-24
-- Description: Removes duplicate/redundant columns that were verified to be empty.
-- These columns (bank_account, variable_symbol, etc.) duplicate existing functionality
-- (bank_account_id, vs, etc.) and were likely introduced by schema drift.

BEGIN;

DO $$
BEGIN
    -- Only drop if they exist to be safe/idempotent
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='bank_account') THEN
        ALTER TABLE eshop.transactions DROP COLUMN bank_account;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='counterparty_account_number') THEN
        ALTER TABLE eshop.transactions DROP COLUMN counterparty_account_number;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='variable_symbol') THEN
        ALTER TABLE eshop.transactions DROP COLUMN variable_symbol;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='message') THEN
        ALTER TABLE eshop.transactions DROP COLUMN message;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='remitted_at') THEN
        ALTER TABLE eshop.transactions DROP COLUMN remitted_at;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='type') THEN
        ALTER TABLE eshop.transactions DROP COLUMN "type";
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='status') THEN
        ALTER TABLE eshop.transactions DROP COLUMN status;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='note') THEN
        ALTER TABLE eshop.transactions DROP COLUMN note;
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='eshop' AND table_name='transactions' AND column_name='updated_at') THEN
        ALTER TABLE eshop.transactions DROP COLUMN updated_at;
    END IF;

END $$;

COMMIT;
-- Fix transactions constraint to allow NULL transaction_id (for email imports using external_id)
BEGIN;

ALTER TABLE eshop.transactions ALTER COLUMN transaction_id DROP NOT NULL;

COMMIT;
-- Restore Fuzzy Deduplication logic missing from recent consolidation
BEGIN;

CREATE OR REPLACE FUNCTION public.process_email_transaction(
    p_data jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
DECLARE
    v_bank_account_id bigint;
    v_external_id text;
    v_transaction_id bigint;
    v_variable_symbol text;
    
    v_existing_id bigint;
    v_new_id int;
    v_payment_info_id bigint;
    v_amount numeric;
    v_date timestamptz;
BEGIN
    v_bank_account_id := (p_data->>'bank_account_id')::bigint;
    v_external_id := p_data->>'external_id';
    v_transaction_id := (p_data->>'transaction_id')::bigint;
    v_variable_symbol := p_data->>'vs';
    v_amount := (p_data->>'amount')::numeric;
    v_date := (p_data->>'date')::timestamptz;

    IF v_bank_account_id IS NOT NULL THEN
        UPDATE eshop.bank_accounts 
        SET last_fetch_time = now(), 
            updated_at = now() 
        WHERE id = v_bank_account_id;
    END IF;

    -- 1. Check Exact Transaction ID (Bank ID)
    IF v_transaction_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE bank_account_id = v_bank_account_id AND transaction_id = v_transaction_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_transaction_id', 'id', v_existing_id);
        END IF;
    END IF;

    -- 2. Check Exact External ID (Message ID)
    IF v_external_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE external_id = v_external_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_external_id', 'id', v_existing_id);
        END IF;
    END IF;

    -- 3. Fuzzy Deduplication (Same VS + Amount + Date)
    -- Prevent re-importing same transaction if ID is missing (e.g. manual entry vs email)
    IF v_variable_symbol IS NOT NULL AND v_amount IS NOT NULL THEN
        SELECT id INTO v_existing_id
        FROM eshop.transactions
        WHERE bank_account_id = v_bank_account_id
          AND vs = v_variable_symbol
          AND amount = v_amount
          AND date = v_date -- Strict date match (usually safe for same-source, but risky if sources differ timezone)
          LIMIT 1;
          
        IF v_existing_id IS NOT NULL THEN
             RETURN jsonb_build_object('status', 'skipped', 'reason', 'fuzzy_duplicate', 'id', v_existing_id);
        END IF;
    END IF;

    INSERT INTO eshop.transactions (
        bank_account_id,
        amount,
        currency,
        counter_account,
        bank_code,
        vs,
        ks,
        ss,
        message_for_recipient,
        date,
        created_at,
        external_id,
        transaction_id,
        counter_account_name
    ) VALUES (
        v_bank_account_id,
        v_amount,
        p_data->>'currency',
        p_data->>'counter_account',
        p_data->>'bank_code',
        v_variable_symbol,
        p_data->>'ks',
        p_data->>'ss',
        p_data->>'message',
        v_date,
        now(),
        v_external_id,
        v_transaction_id,
        p_data->>'sender_name'
    )
    RETURNING id INTO v_new_id;

    IF v_variable_symbol IS NOT NULL AND v_variable_symbol != '' THEN
        BEGIN
            SELECT id INTO v_payment_info_id
            FROM eshop.payment_info
            WHERE variable_symbol = v_variable_symbol::bigint
            LIMIT 1;
        EXCEPTION WHEN OTHERS THEN
             v_payment_info_id := NULL;
        END;

        IF v_payment_info_id IS NOT NULL THEN
             PERFORM public.add_transaction_to_payment_info(v_new_id::bigint, v_payment_info_id);
        END IF;
    END IF;

    RETURN jsonb_build_object('status', 'inserted', 'id', v_new_id, 'paired', v_payment_info_id IS NOT NULL);
END;
$$;

COMMIT;
BEGIN;

-- 1. Update any pairing_code with invalid length to a new valid one
-- We use the same logic as the regenerate function (5 bytes hex = 10 chars)
UPDATE eshop.bank_accounts
SET pairing_code = encode(gen_random_bytes(5), 'hex')
WHERE pairing_code IS NOT NULL AND length(pairing_code) != 10;

-- 2. Add Constraint
ALTER TABLE eshop.bank_accounts
DROP CONSTRAINT IF EXISTS check_pairing_code_length;

ALTER TABLE eshop.bank_accounts
ADD CONSTRAINT check_pairing_code_length CHECK (pairing_code IS NULL OR length(pairing_code) = 10);

-- 3. Fix Default Value (was gen_random_uuid())
ALTER TABLE eshop.bank_accounts 
ALTER COLUMN pairing_code SET DEFAULT encode(gen_random_bytes(5), 'hex');

COMMIT;
BEGIN;

-- 1. Ensure Pairing Code is Unique
ALTER TABLE eshop.bank_accounts
DROP CONSTRAINT IF EXISTS bank_accounts_pairing_code_key;

ALTER TABLE eshop.bank_accounts
ADD CONSTRAINT bank_accounts_pairing_code_key UNIQUE (pairing_code);

-- 2. Fix Timezone in set_last_fetch_time
CREATE OR REPLACE FUNCTION public.set_last_fetch_time(p_bank_account_id bigint)
RETURNS void AS $$
BEGIN
  UPDATE eshop.bank_accounts
  SET last_fetch_time = now() AT TIME ZONE 'UTC'
  WHERE id = p_bank_account_id;
END;
$$ LANGUAGE plpgsql;

-- 3. Expose Pairing RPC publicly (Fixes 404 and Case Sensitivity)
CREATE OR REPLACE FUNCTION public.get_bank_account_by_pairing_code(p_code text)
RETURNS TABLE (
    id bigint,
    type text,
    account_number text
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ba.id,
        ba.type,
        ba.account_number
    FROM eshop.bank_accounts ba
    WHERE LOWER(ba.pairing_code) = LOWER(TRIM(p_code));
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_bank_account_by_pairing_code TO service_role;
GRANT EXECUTE ON FUNCTION public.get_bank_account_by_pairing_code TO anon;
GRANT EXECUTE ON FUNCTION public.get_bank_account_by_pairing_code TO authenticated;

-- 4. Update process_email_transaction (Fuzzy Deduplication + Timezone Fix)
CREATE OR REPLACE FUNCTION public.process_email_transaction(
    p_data jsonb
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, eshop, extensions
AS $$
DECLARE
    v_bank_account_id bigint;
    v_external_id text;
    v_transaction_id bigint;
    v_variable_symbol text;
    v_bank_code text;
    v_bank_name text;
    
    v_existing_id bigint;
    v_new_id int;
    v_payment_info_id bigint;
    v_date timestamptz;
BEGIN
    v_bank_account_id := (p_data->>'bank_account_id')::bigint;
    v_external_id := p_data->>'external_id';
    v_transaction_id := (p_data->>'transaction_id')::bigint;
    v_variable_symbol := p_data->>'vs';
    v_bank_code := p_data->>'bank_code';
    v_date := (p_data->>'date')::timestamptz;
    
    -- Derive bank_name from code if not provided in JSON
    v_bank_name := p_data->>'bank_name';
    IF v_bank_name IS NULL AND v_bank_code IS NOT NULL THEN
        v_bank_name := public.get_bank_name_from_code(v_bank_code);
    END IF;

    IF v_bank_account_id IS NOT NULL THEN
        UPDATE eshop.bank_accounts 
        SET last_fetch_time = now() AT TIME ZONE 'UTC', 
            updated_at = now() 
        WHERE id = v_bank_account_id;
    END IF;

    IF v_transaction_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE bank_account_id = v_bank_account_id AND transaction_id = v_transaction_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_transaction_id', 'id', v_existing_id);
        END IF;
    END IF;

    IF v_external_id IS NOT NULL THEN
        SELECT id INTO v_existing_id 
        FROM eshop.transactions 
        WHERE external_id = v_external_id
        LIMIT 1;
        
        IF v_existing_id IS NOT NULL THEN
            RETURN jsonb_build_object('status', 'skipped', 'reason', 'duplicate_external_id', 'id', v_existing_id);
        END IF;
    END IF;

    -- Fuzzy Deduplication for Email Imports (Missing Transaction ID)
    -- If we have VS and Amount, check if an authoritative transaction (from API, has transaction_id) exists
    IF v_transaction_id IS NULL AND v_variable_symbol IS NOT NULL AND (p_data->>'amount') IS NOT NULL AND v_date IS NOT NULL THEN
         SELECT id INTO v_existing_id
         FROM eshop.transactions
         WHERE bank_account_id = v_bank_account_id
           AND vs = v_variable_symbol
           AND amount = (p_data->>'amount')::numeric
           AND transaction_id IS NOT NULL -- Match against authoritative source
           AND date >= (v_date - interval '3 days')
           AND date <= (v_date + interval '3 days')
         LIMIT 1;

         IF v_existing_id IS NOT NULL THEN
             RETURN jsonb_build_object('status', 'skipped', 'reason', 'fuzzy_duplicate_found', 'id', v_existing_id);
         END IF;
    END IF;

    INSERT INTO eshop.transactions (
        bank_account_id,
        amount,
        currency,
        counter_account,
        bank_code,
        bank_name,
        vs,
        ks,
        ss,
        message_for_recipient,
        date,
        created_at,
        external_id,
        transaction_id,
        counter_account_name
    ) VALUES (
        v_bank_account_id,
        (p_data->>'amount')::numeric,
        p_data->>'currency',
        p_data->>'counter_account',
        v_bank_code,
        v_bank_name,
        v_variable_symbol,
        p_data->>'ks',
        p_data->>'ss',
        p_data->>'message',
        v_date,
        now(),
        v_external_id,
        v_transaction_id,
        p_data->>'sender_name'
    )
    RETURNING id INTO v_new_id;

    IF v_variable_symbol IS NOT NULL AND v_variable_symbol != '' THEN
        BEGIN
            SELECT id INTO v_payment_info_id
            FROM eshop.payment_info
            WHERE variable_symbol = v_variable_symbol::bigint
            LIMIT 1;
        EXCEPTION WHEN OTHERS THEN
             v_payment_info_id := NULL;
        END;

        IF v_payment_info_id IS NOT NULL THEN
             PERFORM public.add_transaction_to_payment_info(v_new_id::bigint, v_payment_info_id);
        END IF;
    END IF;

    RETURN jsonb_build_object('status', 'inserted', 'id', v_new_id, 'paired', v_payment_info_id IS NOT NULL);
END;
$$;

COMMIT;
